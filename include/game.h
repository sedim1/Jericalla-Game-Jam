#ifndef GAME_H
#define GAME_H

#include "glad/glad.h"
#include <math.h>
#include "Textures/MapChecker.h"
#include "Textures/walls.ppm"
#include "Textures/floors.ppm"
#include "Textures/ceiling.ppm"
#include "Textures/witch.ppm"
#include "Textures/muffin.ppm"
#include "Textures/title.ppm"
#include "Textures/loading.ppm"
#include "Queue.h"

#define M_PI 3.14159265358979323846 //180 degrees
#define PI2 M_PI/2.0f // 90 degrees
#define PI3 3.0*(M_PI/2.0f) // 270 degrees
#define D_PI 2.0*M_PI //0 - 360 degrees
#define DR M_PI/180.0f


#define mapWidth 32
#define mapHeight 25
#define CELLSIZE 64
#define PIXELSCALE 8
#define TEXTURE 32
#define NTEX TEXTURE-1
#define MAX 1000

enum SpriteType {
	ENEMY,
	OBJECT,
};
enum PlayerStates{
	MOVING,IDLE,ROTATING
};

enum EnemyAIStates{
	FOLLOW_PLAYER,STILL,
};

enum GameState {
	TITLE,
	LOADING,
	INGAME,
	LOST,
	WIN,
};


typedef struct{
	int left,right,up,down,shift,enter;
}Keys;

typedef struct{
	float x,y;//world position
	float dx,dy; //direction
	float a; //angle
	VECTOR2I nextPos;
	float wPos[2];
	float t;
	enum PlayerStates state;
}Player;

typedef struct{
	int width; //Sprite width per tile
	int height;//Sprite height per tile
	int* tex;
	int visible; //on-off/ 1-0
	float x,y; //World position
	float dist;
	enum SpriteType type;
}Sprite;

typedef struct{
	VECTOR2I points[MAX];
	int current;
	int size;
}PATROL_PATH;

int walls[128][128]={
	{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
	{1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1},
	{1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1},
	{1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1},
	{1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1},
	/////////////////////////////////////////////////////////////////
	{1,1,0,1,1,1,1,1,1,1,2,1,2,1,2,1,2,1,2,1,1,1,2,1,1,2,1,1,2,1,1,1},
	{2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
	{1,0,0,0,0,0,1,0,1,1,1,1,0,0,0,0,1,1,0,1,0,0,0,1,0,1,0,0,1,1,0,2},
	{2,0,0,0,0,1,0,0,0,0,0,0,0,0,1,1,1,1,0,3,0,0,0,1,0,1,0,0,0,0,2,1},
	{1,0,1,0,0,0,0,1,3,3,3,1,0,0,0,0,0,0,0,3,0,0,1,1,0,1,0,1,0,1,0,2},
	{2,0,1,1,1,1,1,3,0,0,0,0,0,1,1,1,1,0,3,3,0,0,0,0,0,1,0,1,0,1,0,1},
	{1,0,1,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,1,0,0,0,1,1,1,0,1,0,1,0,2},
	{2,0,0,0,0,1,1,1,0,0,0,1,0,1,0,1,1,1,0,0,1,1,0,0,0,0,0,0,0,1,0,1},
	{1,0,1,1,0,0,3,3,0,0,0,1,1,1,1,0,0,0,1,0,0,1,0,0,0,1,0,1,0,1,0,2},
	{2,0,0,1,0,0,3,0,0,0,3,0,0,0,1,0,0,0,0,0,1,1,1,1,0,1,0,0,0,1,2,1},
	{1,0,0,1,0,1,3,3,3,0,3,0,1,1,1,1,1,0,1,0,0,0,0,0,0,1,0,1,0,1,0,2},
	{2,0,0,1,0,0,1,1,0,0,1,0,0,0,0,0,0,1,1,0,3,0,3,0,0,1,0,0,0,1,0,1},
	{1,0,0,1,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,1,0,2},
	{2,0,0,1,1,1,3,1,1,1,1,0,0,0,0,0,1,1,0,0,3,0,3,0,1,0,0,0,0,0,0,1},
	{2,0,0,0,0,1,1,1,0,0,1,0,1,1,0,0,0,1,1,0,0,0,0,1,0,0,0,0,0,1,0,2},
	{1,0,0,1,0,1,0,1,0,0,0,0,1,0,0,1,1,0,1,0,0,0,1,0,0,1,1,1,0,1,0,1},
	{2,0,0,1,0,0,0,0,0,1,1,1,1,0,1,0,0,0,1,0,0,1,0,0,0,1,0,1,1,1,0,2},
	{1,1,0,1,3,3,3,0,1,0,0,0,0,0,0,0,0,3,3,0,3,0,0,0,0,1,0,0,1,0,0,1},
	{2,0,0,0,0,0,0,0,0,0,1,1,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,2},
	{1,1,2,1,1,1,1,1,1,1,2,1,2,1,2,1,2,1,2,1,1,1,2,1,1,2,1,1,2,1,1,1},
};

int floors[128][128]={
	{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
	{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
	{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
	{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
	{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
	/////////////////////////////////////////////////////////////////
	{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
	{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
	{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
	{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
	{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
	{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
	{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
	{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
	{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
	{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
	{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
	{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
	{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
	{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
	{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
	{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
	{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
	{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
	{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
	{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
};

int ceiling[128][128]={
	{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
	{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
	{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
	{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
	{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
	/////////////////////////////////////////////////////////////////
	{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
	{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
	{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
	{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
	{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
	{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
	{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
	{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
	{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
	{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
	{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
	{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
	{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
	{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
	{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
	{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
	{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
	{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
	{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
	{1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
};

float radiansAdjust(float radians){
	float res = radians;
	if(radians < 0)  { res = radians + 2 * M_PI;}
	if(radians >= 2 * M_PI)  { res = radians - 2 * M_PI;}
	return res;
}

float distance(float x1, float x2, float y1, float y2){
	float deltaX = x2-x1; float deltaY = y2-y1;
	return sqrt( (deltaX * deltaX) + (deltaY * deltaY) );
}

VECTOR2I BFS(VECTOR2I* start,VECTOR2I* end){
	VECTOR2I actual = {-1,-1};
	int dc[4] = {-1,1,0,0};
	int dr[4] = {0,0,-1,1};
	Queue q; initializeQueue(&q);
	bool reachedEnd = false;
	bool visited[128][128] = {false};
	VECTOR2I cameFrom[128][128]; 
	VECTOR2I neighbor={-1,-1}; VECTOR2I current = *start;
	if(start->x == end->x && start->y == end->y){return *start;}
	enqueue(&q,start); visited[start->y][start->x] = true;
	while(!isEmpty(&q)){
		current = peek(&q); dequeue(&q);
		reachedEnd = current.x == end->x && current.y == end->y;
		if(reachedEnd){break;}
		//Explore neighbors
		for(int i = 0; i < 4; i++){
			neighbor.x = current.x + dc[i]; neighbor.y = current.y + dr[i];
			if(neighbor.x < 0 || neighbor.x >= mapWidth || neighbor.y < 0 || neighbor.y >= mapHeight){continue;}
			if(walls[neighbor.y][neighbor.x] > 0 || visited[neighbor.y][neighbor.x] == true){ continue; }
			enqueue(&q,&neighbor); visited[neighbor.y][neighbor.x] = true; cameFrom[neighbor.y][neighbor.x] = current;
		}
	}
	actual = *end; VECTOR2I next; VECTOR2I last;
	if(!reachedEnd){printf("ERROR:Unreachable location\n");return actual;}
	reachedEnd = false;

	while(!reachedEnd){
		next = cameFrom[actual.y][actual.x];
		reachedEnd = next.x == start->x && next.y == start->y;
		if(!reachedEnd){
			last = actual;
			actual = next;
		}else{
			break;
		}
	}
	return actual;
};

float fogFactor(float distance){
        float fogStart = 40.0f;
    float fogEnd = 280.0f;

    if (distance <= fogStart) return 1.0f;
    if (distance >= fogEnd) return 0.0f;

    return 1.0f - (distance - fogStart) / (fogEnd - fogStart);
}

void adjustCurrentPoint(PATROL_PATH* patrol,int posx,int posy){
	for(int i = 0; i < patrol->size; i++){
		if(patrol->points[i].x == posx && patrol->points[i].y == posy){
			patrol->current; break;
		}
	}
}


#endif
